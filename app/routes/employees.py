from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
import logging
from app.database import get_db
from app.models.employees import Employee
from app.schemas.employees import (
    EmployeeCreate, 
    Employee as EmployeeSchema, 
    EmployeeUpdate,
    EmployeeLogin, 
    TokenWithRefresh, 
    RefreshTokenRequest,
    EmployeePaginatedResponse
)
from app.core.security import create_access_token, create_refresh_token, decode_token, is_refresh_token
from app.core.dependencies import get_current_employee, require_role
from passlib.context import CryptContext

router = APIRouter()
logging.basicConfig(level=logging.INFO)

pwd_context = CryptContext(
    schemes=["argon2"],
    default="argon2",
    deprecated="auto",
)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


@router.post("/register", response_model=EmployeeSchema, status_code=status.HTTP_201_CREATED)
async def register_employee(
    employee: EmployeeCreate, 
    db: Session = Depends(get_db),
    current_employee: Employee = Depends(require_role(["owner", "admin"]))
):
    """Register a new employee - requires owner or admin role"""
    try:
        # Check if email already exists
        db_employee = db.query(Employee).filter(Employee.email == employee.email).first()
        if db_employee:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        # Hash password
        try:
            logging.info(f"Attempting to hash password for employee {employee.name}")
            hashed_password = pwd_context.hash(employee.password)
            logging.info(f"Successfully hashed password for employee {employee.name}")
        except Exception as e:
            logging.error(f"Error hashing password: {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Error processing password: {str(e)}"
            )
        
        # Create new employee (emp_id auto-generated by PostgreSQL sequence starting from 1000)
        db_employee = Employee(
            name=employee.name,
            email=employee.email,
            phone_number=employee.phone_number,
            aadhar_number=employee.aadhar_number,
            address=employee.address,
            city=employee.city,
            state=employee.state,
            country=employee.country,
            role=employee.role,
            joining_date=employee.joining_date,
            custom_fields=employee.custom_fields,
            hashed_password=hashed_password
        )
        
        db.add(db_employee)
        db.commit()
        db.refresh(db_employee)
        
        return EmployeeSchema(
            emp_id=db_employee.emp_id,
            name=db_employee.name,
            email=db_employee.email,
            phone_number=db_employee.phone_number,
            aadhar_number=db_employee.aadhar_number,
            address=db_employee.address,
            city=db_employee.city,
            state=db_employee.state,
            country=db_employee.country,
            role=db_employee.role,
            joining_date=db_employee.joining_date,
            custom_fields=db_employee.custom_fields
        )
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.post("/", response_model=EmployeeSchema, status_code=status.HTTP_201_CREATED)
async def create_employee(
    employee: EmployeeCreate, 
    db: Session = Depends(get_db),
    current_employee: Employee = Depends(require_role(["owner", "admin", "manager"]))
):
    """Create a new employee - requires owner, admin, or manager role"""
    try:
        # Check if email already exists
        db_employee = db.query(Employee).filter(Employee.email == employee.email).first()
        if db_employee:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        # Hash password
        try:
            logging.info(f"Attempting to hash password for employee {employee.name}")
            hashed_password = pwd_context.hash(employee.password)
            logging.info(f"Successfully hashed password for employee {employee.name}")
        except Exception as e:
            logging.error(f"Error hashing password: {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Error processing password: {str(e)}"
            )
        
        # Create new employee (emp_id auto-generated by PostgreSQL sequence starting from 1000)
        db_employee = Employee(
            name=employee.name,
            email=employee.email,
            phone_number=employee.phone_number,
            aadhar_number=employee.aadhar_number,
            address=employee.address,
            city=employee.city,
            state=employee.state,
            country=employee.country,
            role=employee.role,
            joining_date=employee.joining_date,
            custom_fields=employee.custom_fields,
            hashed_password=hashed_password
        )
        
        db.add(db_employee)
        db.commit()
        db.refresh(db_employee)
        
        return EmployeeSchema(
            emp_id=db_employee.emp_id,
            name=db_employee.name,
            email=db_employee.email,
            phone_number=db_employee.phone_number,
            aadhar_number=db_employee.aadhar_number,
            address=db_employee.address,
            city=db_employee.city,
            state=db_employee.state,
            country=db_employee.country,
            role=db_employee.role,
            joining_date=db_employee.joining_date,
            custom_fields=db_employee.custom_fields
        )
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )


@router.get("/", response_model=EmployeePaginatedResponse)
def get_employees(
    skip: int = 0, 
    limit: int = 100,
    filter_field: str = None,
    filter_value: str = None,
    db: Session = Depends(get_db),
    current_employee: Employee = Depends(require_role(["owner", "admin", "manager"]))
):
    """Get all employees with pagination and filtering - requires owner, admin, or manager role"""
    # Start with base query
    query = db.query(Employee)
    
    # Apply filters if provided
    if filter_field and filter_value:
        filter_value_lower = filter_value.lower()
        
        # Handle custom fields filtering
        if filter_field.startswith("custom_"):
            custom_field_name = filter_field.replace("custom_", "")
            # Filter employees with custom fields that match
            # We need to check if any element in the JSON array has the key and contains the value
            from sqlalchemy import cast, String, func
            
            # Get all employees and filter in Python (more reliable for JSON filtering)
            all_employees = query.all()
            matching_ids = []
            
            for emp in all_employees:
                if emp.custom_fields:
                    for field_obj in emp.custom_fields:
                        if custom_field_name in field_obj:
                            field_value = str(field_obj[custom_field_name]).lower()
                            if filter_value_lower in field_value:
                                matching_ids.append(emp.emp_id)
                                break
            
            if matching_ids:
                query = query.filter(Employee.emp_id.in_(matching_ids))
            else:
                # No matches found, return empty result
                query = query.filter(Employee.emp_id == -1)
        else:
            # Regular field filtering
            if filter_field == "emp_id":
                # Exact match for emp_id
                if filter_value.isdigit():
                    query = query.filter(Employee.emp_id == int(filter_value))
            elif filter_field == "name":
                query = query.filter(Employee.name.ilike(f"%{filter_value}%"))
            elif filter_field == "email":
                query = query.filter(Employee.email.ilike(f"%{filter_value}%"))
            elif filter_field == "phone_number":
                query = query.filter(Employee.phone_number.ilike(f"%{filter_value}%"))
            elif filter_field == "aadhar_number":
                query = query.filter(Employee.aadhar_number.ilike(f"%{filter_value}%"))
            elif filter_field == "city":
                query = query.filter(Employee.city.ilike(f"%{filter_value}%"))
            elif filter_field == "state":
                query = query.filter(Employee.state.ilike(f"%{filter_value}%"))
            elif filter_field == "country":
                query = query.filter(Employee.country.ilike(f"%{filter_value}%"))
            elif filter_field == "role":
                query = query.filter(Employee.role.ilike(f"%{filter_value}%"))
    
    # Get total count after filtering
    total = query.count()
    
    # Get paginated employees
    employees = query.offset(skip).limit(limit).all()
    
    # Calculate page number (0-indexed)
    page = skip // limit if limit > 0 else 0
    
    return EmployeePaginatedResponse(
        items=employees,
        total=total,
        page=page,
        page_size=limit
    )


@router.get("/custom-fields/labels", response_model=List[str])
def get_custom_field_labels(
    db: Session = Depends(get_db),
    current_employee: Employee = Depends(require_role(["owner", "admin", "manager"]))
):
    """Get all unique custom field label names - requires owner, admin, or manager role"""
    employees = db.query(Employee).all()
    custom_labels = set()
    
    for employee in employees:
        if employee.custom_fields:
            for field_obj in employee.custom_fields:
                custom_labels.update(field_obj.keys())
    
    return sorted(list(custom_labels))


@router.get("/{emp_id}", response_model=EmployeeSchema)
def get_employee(
    emp_id: int, 
    db: Session = Depends(get_db),
    current_employee: Employee = Depends(require_role(["owner", "admin", "manager"]))
):
    """Get a specific employee - requires owner, admin, or manager role"""
    db_employee = db.query(Employee).filter(Employee.emp_id == emp_id).first()
    if db_employee is None:
        raise HTTPException(status_code=404, detail="Employee not found")
    return db_employee


@router.put("/{emp_id}", response_model=EmployeeSchema)
def update_employee(
    emp_id: int,
    employee_update: EmployeeUpdate,
    db: Session = Depends(get_db),
    current_employee: Employee = Depends(get_current_employee)
):
    """Update an employee - owner/admin/manager can update any, others can update self"""
    db_employee = db.query(Employee).filter(Employee.emp_id == emp_id).first()
    if db_employee is None:
        raise HTTPException(status_code=404, detail="Employee not found")
    
    # Check if employee is updating themselves or if they have elevated privileges
    if current_employee.emp_id != emp_id and current_employee.role not in ["owner", "admin", "manager"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only update your own profile"
        )
    
    # Check if email is being changed and if it's already taken
    if employee_update.email and employee_update.email != db_employee.email:
        email_exists = db.query(Employee).filter(Employee.email == employee_update.email).first()
        if email_exists:
            raise HTTPException(status_code=400, detail="Email already registered")
    
    # Update employee fields
    update_data = employee_update.model_dump(exclude_unset=True)
    
    # Handle password separately if provided
    if "password" in update_data and update_data["password"]:
        update_data["hashed_password"] = pwd_context.hash(update_data.pop("password"))
    
    for field, value in update_data.items():
        setattr(db_employee, field, value)
    
    db.commit()
    db.refresh(db_employee)
    return db_employee


@router.delete("/{emp_id}", status_code=status.HTTP_200_OK)
def delete_employee(
    emp_id: int, 
    db: Session = Depends(get_db),
    current_employee: Employee = Depends(require_role(["owner", "admin"]))
):
    """Delete an employee - requires owner or admin role"""
    db_employee = db.query(Employee).filter(Employee.emp_id == emp_id).first()
    if db_employee is None:
        raise HTTPException(status_code=404, detail="Employee not found")

    db.delete(db_employee)
    db.commit()
    return {"emp_id": emp_id, "detail": "deleted successfully"}


@router.post("/auth", response_model=TokenWithRefresh)
async def authenticate_employee(employee_details: EmployeeLogin, db: Session = Depends(get_db)):
    """Login endpoint for employees"""
    logging.info(f"Authenticating employee with email: {employee_details.email}")
    db_employee = db.query(Employee).filter(Employee.email == employee_details.email).first()
    if not db_employee or not verify_password(employee_details.password, db_employee.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )

    # Create JWT access token and refresh token
    access_token = create_access_token({"sub": str(db_employee.emp_id), "role": db_employee.role})
    refresh_token = create_refresh_token({"sub": str(db_employee.emp_id), "role": db_employee.role})
    return {"access_token": access_token, "token_type": "bearer", "refresh_token": refresh_token}


@router.post("/refresh", response_model=TokenWithRefresh)
async def refresh_token(request: RefreshTokenRequest):
    """Refresh access token using refresh token"""
    # Validate refresh token
    if not is_refresh_token(request.refresh_token):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid refresh token")

    payload = decode_token(request.refresh_token)
    if not payload:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or expired refresh token")

    emp_id = payload.get("sub")
    role = payload.get("role")

    access_token = create_access_token({"sub": str(emp_id), "role": role})
    new_refresh = create_refresh_token({"sub": str(emp_id), "role": role})
    return {"access_token": access_token, "token_type": "bearer", "refresh_token": new_refresh}
